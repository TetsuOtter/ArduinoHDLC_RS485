# ArduinoHDLC_RS485

Arduino で RS485 通信を行うためのライブラリを実装します。
上位プロトコルは HDLC で、この部分も実装します。
使用する RS485 ドライバは LTC485CN8 です。つまり特定のピンの ON/OFF でラインの状態を切り替えます。

さて、クラスの設計を考えます。

今回は、伝送路符号や BaudRate を考慮しつつ RS485 ドライバの制御を行う「RS485Driver」クラスと、CRC 計算や HDLC プロトコルを実装する「HDLC」クラスを作成します。

## RS485Driver クラス

RS485Driver クラスは、RS485 通信の基本的な制御を行います。
このクラスは、以下の機能を持ちます。

- RS485 ドライバの初期化
- データの送信
- データの受信
- 受信/送信の切り替え

なお、RS485Driver クラスでは、一旦はマスターノードの実装のみを考慮する形で問題ありません。

データの送信にあたっては、送信するデータをビット単位で受け取ります。
受信に関しては、1 ビット受信するごとにコールバック関数を呼び出す形で実装します。
なお、受信は割り込みを使用して行います。

送信するデータの量はそこまで多くないため、ブロッキングで送信を行う形で問題ありません。
つまり、送信するデータを全て送信し終わるまで、次の処理に進まない形で実装します。
なお、当然ながら、受信中は送信を行うことはできません。

## HDLC クラス

HDLC クラスは、HDLC プロトコルに基づくデータの送受信を行います。
このクラスは、以下の機能を持ちます。

- データのフレーミング
- CRC 計算
- データの送信
- データの受信
- 受信データの検証

HDLC クラスでは、データをフレーム化し、CRC を計算して送信します。
受信したデータは、フレームの検証を行い、正しいデータのみを受け取ります。
また、受信したデータの CRC チェックも行います。

受信したデータは、コールバック関数が指定されていればそれを呼び出し、指定されていなければキューに格納し、関数による読み出しを待ちます。

## 実装の流れ

1. RS485Driver クラスを実装し、RS485 通信の基本的な制御を行います。
2. HDLC クラスを実装し、HDLC プロトコルに基づくデータの送受信を行います。
3. RS485Driver クラスと HDLC クラスを統合し、RS485 通信を行うアプリケーションを作成します。

簡単のため、今回は Serial で受信したデータを HDLC で送信する形にします。
Serial 経由で送られてくるデータは、バイナリ文字列です。つまり、`00 F0`といったように、16 進数を表現した文字列が送られてきます。
このデータを HDLC で送信するために、まずは 16 進数の文字列をバイト配列に変換します。
その後、HDLC でフレーム化し、CRC を計算して送信します。なお、送られてくる文字列はアドレスを含んだものとします。

データの受信についてはコールバック関数を使用する形にし、受信したデータはリクエストと同じように、16 進数の文字列として返す形にします。

## 実装完了

### 実装されたファイル

1. **include/RS485Driver.h** - RS485Driver クラスのヘッダー
2. **src/RS485Driver.cpp** - RS485Driver クラスの実装
3. **include/HDLC.h** - HDLC クラスのヘッダー
4. **src/HDLC.cpp** - HDLC クラスの実装
5. **src/main.cpp** - メインアプリケーション
6. **test/test_rs485_driver.cpp** - RS485Driver の単体テスト
7. **test/test_hdlc.cpp** - HDLC の単体テスト
8. **test/test_main.cpp** - テスト実行用メイン
9. **examples/basic_usage.cpp** - 使用例
10. **docs/API_REFERENCE.md** - API リファレンス

### 主な機能

#### RS485Driver クラス

- LTC485CN8 を使用した RS485 通信制御
- ビット単位でのデータ送信（ブロッキング）
- 割り込みベースでの受信
- 送信/受信モードの自動切り替え

#### HDLC クラス

- HDLC フレーミング（フラグ、バイトスタッフィング）
- CRC-16 計算とデータ検証
- 16 進数文字列とバイト配列の相互変換
- コールバックベースの受信処理
- 受信データキューイング

### 使用方法

#### ビルド

```bash
pio run
```

#### テスト実行

```bash
pio test
```

#### 基本的な使用例

```cpp
#include "RS485Driver.h"
#include "HDLC.h"

RS485Driver driver(2, 3, 4, 5, 9600); // TX, RX, DE, RE, BaudRate
HDLC hdlc(driver);

void setup() {
    hdlc.begin();

    // 16進数文字列での送信
    hdlc.transmitHexString("01 02 03 FF");

    // 受信コールバック設定
    hdlc.setReceiveCallback([](const uint8_t* data, size_t length, bool isValid) {
        // 受信処理
    });

    // ポーリングベースで受信を試行
    // hdlc.receiveFrameWithBitControl(5000); // タイムアウト: 5秒
}
}
```

### ピン配置（Arduino Uno）

| 機能 | ピン | 説明               |
| ---- | ---- | ------------------ |
| TX   | D2   | RS485 送信データ   |
| RX   | D3   | RS485 受信データ   |
| DE   | D4   | ドライバイネーブル |
| RE   | D5   | レシーバイネーブル |

### 特徴

- フル機能の HDLC プロトコル実装
- CRC-16 による誤り検出
- バイトスタッフィング対応
- 16 進数文字列での簡単な操作
- 包括的な単体テスト
- 詳細な API ドキュメント

詳細な使用方法については `docs/API_REFERENCE.md` を参照してください。
